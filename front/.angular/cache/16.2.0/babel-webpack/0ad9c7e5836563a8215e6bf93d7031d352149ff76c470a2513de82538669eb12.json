{"ast":null,"code":"import { of, throwError } from 'rxjs';\nimport { catchError, map, retry } from 'rxjs/operators';\nimport { environment } from '../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let WeatherService = /*#__PURE__*/(() => {\n  var _class;\n  class WeatherService {\n    constructor(http) {\n      this.http = http;\n      this.API_BASE_URL = 'https://api.openweathermap.org';\n      this.GEOCODE_CACHE = new Map();\n      this.WEATHER_CACHE = new Map();\n      this.CACHE_DURATION = 10 * 60 * 1000; // 10 minutes\n    }\n    /**\n     * Géocode un lieu (nom de ville) en coordonnées lat/lon\n     */\n    geocodeLocation(location) {\n      // Vérifier le cache\n      if (this.GEOCODE_CACHE.has(location)) {\n        return of(this.GEOCODE_CACHE.get(location));\n      }\n      const url = `${this.API_BASE_URL}/geo/1.0/direct`;\n      const params = {\n        q: location,\n        limit: '1',\n        appid: environment.weatherApiKey\n      };\n      return this.http.get(url, {\n        params\n      }).pipe(retry(2), map(response => {\n        if (response && response.length > 0) {\n          const result = {\n            lat: response[0].lat,\n            lon: response[0].lon\n          };\n          // Mettre en cache\n          this.GEOCODE_CACHE.set(location, result);\n          return result;\n        }\n        throw new Error('Lieu non trouvé');\n      }), catchError(error => {\n        console.error('Erreur de géocodage:', error);\n        return throwError(() => new Error('Impossible de géocoder le lieu'));\n      }));\n    }\n    /**\n     * Récupère les prévisions météo pour les 5 prochains jours\n     */\n    getWeatherForecast(lat, lon) {\n      const cacheKey = `${lat},${lon}`;\n      // Vérifier le cache\n      const cached = this.WEATHER_CACHE.get(cacheKey);\n      if (cached) {\n        return of(cached);\n      }\n      const url = `${this.API_BASE_URL}/data/2.5/forecast`;\n      const params = {\n        lat: lat.toString(),\n        lon: lon.toString(),\n        appid: environment.weatherApiKey,\n        units: 'metric',\n        lang: 'fr'\n      };\n      return this.http.get(url, {\n        params\n      }).pipe(retry(2), map(response => {\n        const forecasts = this.transformWeatherData(response);\n        // Mettre en cache\n        this.WEATHER_CACHE.set(cacheKey, forecasts);\n        // Nettoyer le cache après la durée spécifiée\n        setTimeout(() => {\n          this.WEATHER_CACHE.delete(cacheKey);\n        }, this.CACHE_DURATION);\n        return forecasts;\n      }), catchError(error => {\n        console.error('Erreur de récupération météo:', error);\n        return throwError(() => new Error('Impossible de récupérer les prévisions météo'));\n      }));\n    }\n    /**\n     * Transforme les données de l'API en format WeatherForecast\n     * Groupe les prévisions par jour et prend la moyenne/meilleure valeur\n     */\n    transformWeatherData(response) {\n      const dailyForecasts = new Map();\n      response.list.forEach(item => {\n        const date = new Date(item.dt * 1000);\n        const dateKey = this.formatDateKey(date);\n        // Prendre la prévision de midi (12h) si disponible, sinon la première de la journée\n        const hour = date.getHours();\n        const isBestTime = hour >= 11 && hour <= 14;\n        if (!dailyForecasts.has(dateKey) || isBestTime) {\n          const weather = item.weather[0];\n          dailyForecasts.set(dateKey, {\n            date: new Date(date.getFullYear(), date.getMonth(), date.getDate()),\n            temperature: item.main.temp,\n            temperatureMin: item.main.temp_min,\n            temperatureMax: item.main.temp_max,\n            description: weather.description,\n            icon: weather.icon,\n            humidity: item.main.humidity,\n            windSpeed: item.wind.speed * 3.6 // Conversion m/s en km/h\n          });\n        } else {\n          // Mettre à jour min/max si nécessaire\n          const existing = dailyForecasts.get(dateKey);\n          if (item.main.temp_min < existing.temperatureMin) {\n            existing.temperatureMin = item.main.temp_min;\n          }\n          if (item.main.temp_max > existing.temperatureMax) {\n            existing.temperatureMax = item.main.temp_max;\n          }\n        }\n      });\n      return Array.from(dailyForecasts.values()).slice(0, 5); // Limiter à 5 jours\n    }\n    /**\n     * Formate une date en clé string (YYYY-MM-DD)\n     */\n    formatDateKey(date) {\n      const year = date.getFullYear();\n      const month = String(date.getMonth() + 1).padStart(2, '0');\n      const day = String(date.getDate()).padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    }\n  }\n  _class = WeatherService;\n  _class.ɵfac = function WeatherService_Factory(t) {\n    return new (t || _class)(i0.ɵɵinject(i1.HttpClient));\n  };\n  _class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac,\n    providedIn: 'root'\n  });\n  return WeatherService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}